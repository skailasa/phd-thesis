\thispagestyle{plain}

\begin{center}
    \textbf{Abstract}
\end{center}

The past three decades have seen the emergence of so called `fast algorithms' that are able to optimally apply and invert dense matrices that exhibit a special low-rank structure in their off-diagonal elements. Such matrices arise in numerous areas of science and engineering, for example in the linear system matrices of boundary integral formulations of problems from acoustics and electromagnetics to fluid dynamics, geomechanics and even seismology. In the best case matrices can be stored, applied and inverted in $O(N)$, in contrast to $O(N^2)$ for storage and application, and $O(N^3)$ for inversion when computed naively.

The unification of software for the forward and inverse application of these operators in a single set of open-source libraries optimised for distributed computing environments is lacking, and is the central concern of this research project. We propose the creation of a unified solver infrastructure that can demonstrates good weak scaling from local workstations to upcoming exascale machines. Developing high-performance implementations of fast algorithms is challenging due to highly-technical nature of their underlying mathematical machinery, further complicated by the diversity of software and hardware environments in which research code is expected to run.

This subsidiary thesis presents current progress towards this goal. Chapter \ref{chpt:2:fmms} introduces the Fast Multipole Method (FMM), the prototypical fast algorithm for $O(N)$ matrix vector products, and discusses implementation strategies in the context of high-performance software implementations. Chapter \ref{chpt:3:software_landscape} provides a survey of the fragmented parallel software landscape for fast algorithms. In chapter \ref{chpt:4:pyexafmm} we consider the trade-offs of implementing our codes in high-level languages via our experience of developing an FMM in Python, which attempted to bridge the gap between a familiar and ergonomic language for researchers and achieving high-performance. Despite its many advantages, including cross-platform support and large numerics ecosystem, we find Python and high-level languages in general to be inadequate for our purposes. In chapter \ref{chpt:5:rust} we introduce Rust as our proposed solution for ergonomic and high-performance codes for computational science. Rust is a modern compiled programming language, which we contrast with our experience developing software with Fortran and C++. In chapter \ref{chpt:6:rusty_tree} we present a demonstrative Rust software output, Rusty Tree, a new Rust-based library for the construction of parallel octrees. Octrees are a foundational data structure for FMMs, as well as other fast algorithms. Finally chapter \ref{chpt:7:fds} presents an emerging vector in our research, specifically an overview of a recently developed fast algorithm for matrix inversion for the solution of acoustic scattering problems as described by the Helmholtz equation.
