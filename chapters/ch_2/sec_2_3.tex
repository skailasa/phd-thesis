\section{Building for Re-Use in Fast Algorithm Software}\label{chpt:2:sec:3}

High performance software for the core data structure of quad/octrees is essential to all fast algorithms. Indeed, these hierarchical discretisations are found across scientific computing applications [REFERENCES FOR APPLICATIONS OF TREES]. Similarly, methods for sparsifying the $T^{M2L}$ operator, whether that be via an SVD or FFT, can also be re-used in the implementation of fast direct solvers, or alternative algebraic FMMs such as the bbFMM of Fong and Darve \cite{fong2009black}. The same is true of software for evaluating kernel functions in $P2P$ operator. We identify the decoupling of these separate components to be rare in other softwares for fast algorithms \cite{malhotra2015pvfmm,wang2021exafmm,h2lib2016github}, which are often presented as a monolith to users, making it difficult for developers to extend or adapt this software to their use-case.

Our software is designed to be de-coupled as independent sub-components. We achieve this using Cargo, which allows the development of `workspaces'. This is a modern language feature, without a direct parallel provided in competitors such as Fortran or C/C++. With workspaces, all sub-packages (known as `crates' in Rust) share a common build directory - speeding up build compile times, and ensuring that dependencies are uniformly versioned across all crates, specified by a root level TOML dependency file. Indeed, crates within a workspace can be specified to be binaries, libraries, or both, allowing for sub-components to easily be deployed independently or used as a dependency by a downstream developer.

- Explain in detail how traits work to specify shared behaviour in comparison to oop

- what are the trad-offs with traits (orphan rule)
- what are the benefits (implement for non-local types)
    - e.g. developers can change our kernel/translation implementations
    - implement open/close principle - composition
    - diamond problem, e.g. multiple inheritors which implement a base class, is not a thing.
    - all the polymorphism is compile time (runtime via trait objects?)
        - I don't think this is a big criticism really, relatively similar.
    - FMM/Fast algorithms naturally fall into sub-components
        - e.g. trees, translation operators, share large parts of algorithm structure.
        - packaging data with behaviour as with oop is difficult, as data structures are often very different.
            - much easier to implement a trait over a type, vs creating a completely new class for each type
                - clearer to glue together using trait contracts.



- How the design of, say translation operators, is relatively generic and plug and play.
- same for P2P, via traits as well, can plug in a GPU implementation say.
