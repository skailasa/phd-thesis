Robust parallel tree data structures are critical for high performance fast algorithms. The tree is the defining 

- Explain criticality of tree for FMM, where the global reductions are comms bottlenecks in the FMM.

- The novelty isn't the fact that it's a parallel octree, of which there are many, it's that it's one that you can use easily from Python, and deploy to different HPC environments and architectures, with a simple API.

- What do we want from an octree library? load balancing, simple API, MPI distributed.

\subsection*{Parallel Octrees}

- Construction algorithms, briefly, sorting algorithm (key), sketch.

- introduce tree algorithms (parallel sorting, parallel tree construction, load balancing) as well as idea and reasoning behind morton encoding. How do we do this fast? 

\subsection*{Developing a Python Interface}
- Talk about the ease of writing a Python interface, and how this interoperability works.

\subsection*{Scaling Experiments}

- Scaling test on a large HPC system (Myriad/Archer2) scale to a very large tree (O(1e9)) points, use as a Python package.  O(billions of points)

- Compare to existing tree libraries if possible and time permits.

\subsection*{Conclusion}

- Contrast with existing tree libraries, their performance on different architectures, and how easy they are to install and edit. i.e. contrast how malleable they are.
