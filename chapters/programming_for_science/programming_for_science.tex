\chapter{Modern Programming Environments for Science}\label{chpt:programming_for_science}
\thispagestyle{chaptertitle} % Force the fancy style on this page



\begin{center}
    \textit{The discussion in this chapter, including figures and diagrams, is adapted from the material first presented in \cite{kailasa2022pyexafmm}.}
\end{center}

\section{Requirements for Research Software}

- Requirements and constraints on research software development.

- The complexity of methods leads to complex code surface areas which are difficult to maintain especially in an academic setting with few resources for professional software engineering practice.

- The diversity of hardware and software backends leads to increasing difficulty for projects to experiment with and incorporate computational advances.

- Hardware and software complexity, and gap between a one-off coding project and extensible maintainable software tooling.

- Review developments in computer hardware and software that make this easier to be more productive, but also more challenging to wrap together over time.

- Emerging and future trends, exemplified by the step change in compiled langauges in the new generation and the interest in Rust and similar langauges. The mojo project and what this says about the future.


\section{Low Level or High Level? Balancing Programming Environments with Performance Requirements}

- Summary of Python paper results, in summary complex algorithms necessitate complex code in order to achieve performance - specifically the requirement for programmers to be in charge of memory and for hot sections manually vectorise etc. Writing everything in a high-level language obfuscates the application code from the sections critical to performance

- Review of why this was thought to be a good idea, and why it might be worth trying again in the future.

- What problems does this paper address, wrt to the literature?

- Brief review of motivation and reasoning behind Rust, and which features we take advantage of

- Review of data oriented design, how this can be enabled with traits.

% \input{chapters/ch_1/sec_1_0.tex}
% \input{chapters/ch_1/sec_1_1.tex}
% \input{chapters/ch_1/sec_1_2.tex}
% \input{chapters/ch_1/sec_1_3.tex}
